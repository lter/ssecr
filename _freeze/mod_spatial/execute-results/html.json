{
  "hash": "1b5581aa6270c626fe7bb93dc15369cc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Working with Spatial Data\"\ncode-annotations: hover\n---\n\n\n\n\n## Overview\n\nSynthesis projects often have need of spatial datasets. At its simplest, it can be helpful to have a map of the original project locations including in the synthesis dataset. In more complex instances you want to extract spatial data within a certain area of sampling locations. Regardless of 'why' you're using spatial data, it may come up during your primary or synthesis work and thus deserves consideration in this course's materials. There are _many_ modes of working with spatial data, and not all of these tools require coding literacy but for consistency with the rest of the modules **this module will focus on _scripted_ approaches to interacting with spatial data**.\n\n## Learning Objectives\n\nAfter completing this topic you will be able to: \n\n- <u>Define</u> the difference between the two major types of spatial data\n- <u>Manipulate</u> spatial data with R\n- <u>Integrate</u> spatial data with tabular data\n\n## Needed Packages\n\nIf you'd like to follow along with the code chunks included throughout this module, you'll need to install the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note that these lines only need to be run once per computer\n## So you can skip this step if you've installed these before\ninstall.packages(\"tidyverse\")\ninstall.packages(\"sf\")\ninstall.packages(\"terra\")\n```\n:::\n\n\n## Types of Spatial Data\n\nThere are two main types of spatial data: vector and raster. Both types (and the packages they require) are described in the tabs below.\n\n:::{.panel-tabset}\n### Vector Data\n\nVector data are stored as polygons. Essentially vector data are a set of points and--sometimes--the lines between them that define the edges of a shape. They may store additional data that is retained in a semi-tabular format that relates to the polygon(s) but isn't directly stored in them.\n\nCommon vector data types include shape files or GeoJSONs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load needed library\nlibrary(sf)\n\n# Read in shapefile\nnc_poly <- sf::st_read(dsn = file.path(\"data\", \"nc_borders.shp\")) #<1>\n```\n:::\n\n1. Note that even though we're only specifying the \".shp\" file in this function you _must_ also have the associated files in that same folder. In this case that includes a \".dbf\", \".prj\", and \".shx\", though in other contexts you may have others.\n\nOnce you have read in the shapefile, you can check its structure as you would any other data object. Note that the object has both the 'data.frame' class and the 'sf' (\"simple features\") class. In this case, the shapefile relates to counties in North Carolina and some associated demographic data in those counties.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check structure\nstr(nc_poly)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'sf' and 'data.frame':\t100 obs. of  15 variables:\n $ AREA     : num  0.114 0.061 0.143 0.07 0.153 0.097 0.062 0.091 0.118 0.124 ...\n $ PERIMETER: num  1.44 1.23 1.63 2.97 2.21 ...\n $ CNTY_    : num  1825 1827 1828 1831 1832 ...\n $ CNTY_ID  : num  1825 1827 1828 1831 1832 ...\n $ NAME     : chr  \"Ashe\" \"Alleghany\" \"Surry\" \"Currituck\" ...\n $ FIPS     : chr  \"37009\" \"37005\" \"37171\" \"37053\" ...\n $ FIPSNO   : num  37009 37005 37171 37053 37131 ...\n $ CRESS_ID : int  5 3 86 27 66 46 15 37 93 85 ...\n $ BIR74    : num  1091 487 3188 508 1421 ...\n $ SID74    : num  1 0 5 1 9 7 0 0 4 1 ...\n $ NWBIR74  : num  10 10 208 123 1066 ...\n $ BIR79    : num  1364 542 3616 830 1606 ...\n $ SID79    : num  0 3 6 2 3 5 2 2 2 5 ...\n $ NWBIR79  : num  19 12 260 145 1197 ...\n $ geometry :sfc_MULTIPOLYGON of length 100; first list element: List of 1\n  ..$ :List of 1\n  .. ..$ : num [1:27, 1:2] -81.5 -81.5 -81.6 -81.6 -81.7 ...\n  ..- attr(*, \"class\")= chr [1:3] \"XY\" \"MULTIPOLYGON\" \"sfg\"\n - attr(*, \"sf_column\")= chr \"geometry\"\n - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA NA NA NA NA NA ...\n  ..- attr(*, \"names\")= chr [1:14] \"AREA\" \"PERIMETER\" \"CNTY_\" \"CNTY_ID\" ...\n```\n\n\n:::\n:::\n\n\nIf desired, we could make a simple R base plot-style map. In this case we'll do it based on just the county areas so that the polygons are filled with a color corresponding to how large the county is.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Make a graph\nplot(nc_poly[\"AREA\"], axes = T)\n```\n\n::: {.cell-output-display}\n![](mod_spatial_files/figure-html/plot-vector-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n### Raster Data\n\nRaster data are stored as values in pixels. The resolution (i.e., size of the pixels) may differ among rasters but in all cases the data are stored at a per-pixel level.\n\nCommon raster data types include GeoTIFFs (.tif) and NetCDF (.nc) files.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load needed library\nlibrary(terra)\n\n# Read in raster\nnc_pixel <- terra::rast(x = file.path(\"data\", \"nc_elevation.tif\"))\n```\n:::\n\n\nOnce you've read in the raster file you can check it's structure as you would any other object but the resulting output is much less informative than for other object classes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check structure\nstr(nc_pixel)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nS4 class 'SpatRaster' [package \"terra\"]\n```\n\n\n:::\n:::\n\n\nRegardless, now that we have the raster loaded we can make a simple graph to check out what sort of data is stored in it. In this case, each pixel is 3 arcseconds on each side (~0.0002Â° latitude/longitude) and contains the elevation (in meters) of that pixel.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Make a graph\nterra::plot(nc_pixel)\n```\n\n::: {.cell-output-display}\n![](mod_spatial_files/figure-html/plot-raster-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n:::\n\n## Coordinate Reference Systems\n\nA fundamental problem in spatial data is how to project data collected on a nearly spherical planet onto a two-dimensional plane. This has been solved--or at least clarified--by the use of <u>C</u>oordinate <u>R</u>eference <u>S</u>ystems (a.k.a. \"CRS\"). All spatial data have a CRS that is explicitly identified in the data and/or the metadata because the data _are not interpretable_ without knowing which CRS is used.\n\n\nThe CRS defines the following information:\n\n1. **Datum** -- model for shape of the Earth including the starting coordinate pair and angular units that together define any particular point on the planet\n    - Note that there can be global datums that work for any region of the world and local datums that only work for a particular area\n2. **Projection** -- math for the transformation to get from a round planet to a flat map\n3. **Additional parameters** -- any other information necessary to support the projection\n    - E.g., the coordinates at the center of the map\n\nSome people use the analogy of peeling a citrus fruit and flattening the peel to describe the components of a CRS. The datum is the choice between a lemon or a grapefruit (i.e., the shape of the not-quite-spherical object) while the projection is the instructions for taking the complete peel and flattening it.\n\nYou can check and transform the CRS in any scripted language that allows the loading of spatial data though the specifics do differ between the two types of spatial data we introduced earlier.\n\n:::{.panel-tabset}\n### Vector CRS\n\n\n`sf::st_crs`\n\n\n::: {.cell}\n\n:::\n\n\n\n`sf::st_transform`\n\n\n::: {.cell}\n\n:::\n\n\n### Raster CRS\n\n`terra::crs`\n\n\n::: {.cell}\n\n:::\n\n\n\n`terra::project`\n\n\n::: {.cell}\n\n:::\n\n\n:::\n\n## Making Maps\n\n\n\n\n\n## Extracting Spatial Data\n\n\n\n\n\n## Additional Spatial Resources\n\n### Papers & Documents\n\n- \n\n### Workshops & Courses\n\n- The Carpentries' [Introduction to Geospatial Raster & Vector Data with R](https://datacarpentry.org/r-raster-vector-geospatial/)\n- The Carpentries' [Introduction to R for Geospatial Data](https://datacarpentry.org/r-intro-geospatial/index.html)\n- Arctic Data Center's [Spatial and Image Data Using GeoPandas](https://learning.nceas.ucsb.edu/2023-03-arctic/sections/geopandas.html) chapter of their Scalable Computing course\n- Jason Flower's (UC Santa Barbara) [Introduction to rasters with `terra`](https://jflowernet.github.io/intro-terra-ecodatascience/)\n- King, R. [Spatial Data Visualization](https://github.com/king0708/spatial-data-viz) workshop\n\n### Websites\n\n- NASA's <u>App</u>lication for <u>E</u>xtracting and <u>E</u>xploring <u>A</u>nalysis <u>R</u>eady <u>S</u>amples [(AppEEARS) Portal](https://appeears.earthdatacloud.nasa.gov/)\n",
    "supporting": [
      "mod_spatial_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}