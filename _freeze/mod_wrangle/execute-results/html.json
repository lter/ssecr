{
  "hash": "0892f8553392caedc811c8c5d003b538",
  "result": {
    "markdown": "---\ntitle: \"Data Harmonization & Wrangling\"\ncode-annotations: hover\n---\n\n\n## Overview\n\nNow that we have covered how to find data and use data visualization methods to explore it, we can move on to combining separate data files and preparing that combined data file for analysis. For the purposes of this module we're adopting a very narrow view of harmonization and a very broad view of wrangling but this distinction aligns well with two discrete philosophical/practical arenas. To make those definitions explicit:\n\n- <u>\"Harmonization\" = process of combining separate primary data objects into one object</u>. This includes things like synonymizing columns, or changing data format to support combination. This _excludes_ quality control steps--even those that are undertaken before harmonization begins.\n\n- <u>\"Wrangling\" = all modifications to data meant to create an analysis-ready 'tidy' data object</u>. This includes quality control, unit conversions, and data 'shape' changes to name a few. Note that attaching ancillary data to your primary data object (e.g., attaching temperature data to a dataset on plant species composition) _also falls into this category!_\n\n## Learning Objectives\n\nAfter completing this module you will be able to: \n\n- <u>Identify</u> typical steps in data harmonization and wrangling workflows\n- <u>Create</u> a harmonization workflow\n- <u>Define</u> quality control\n- <u>Summarize</u> typical operations in a quality control workflow\n- <u>Use</u> regular expressions to perform flexible text operations\n- <u>Write</u> custom functions to reduce code duplication\n- <u>Identify</u> value of and typical obstacles to data 'joining'\n- <u>Explain</u> benefits and drawbacks of using data shape to streamline code\n- <u>Design</u> a complete data wrangling workflow\n\n## Needed Packages\n\nIf you'd like to follow along with the code chunks included throughout this module, you'll need to install the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note that these lines only need to be run once per computer\n## So you can skip this step if you've installed these before\ninstall.packages(\"ltertools\")\ninstall.packages(\"lterdatasampler\")\ninstall.packages(\"psych\")\ninstall.packages(\"supportR\")\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\nWe'll load the Tidyverse meta-package here to have access to many of its useful tools when we need them later.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load tidyverse\nlibrary(tidyverse)\n```\n:::\n\n\n\n## Harmonizing Data\n\nData harmonization is an interesting topic in that it is _vital_ for synthesis projects but only very rarely relevant for primary research. Synthesis projects must reckon with the data choices made by each team of original data collectors. These collectors may or may not have recorded their judgement calls (or indeed, any metadata) but before synthesis work can be meaningfully done these independent datasets must be made comparable to one another and combined.\n\nFor tabular data, we recommend using the [`ltertools` R package](https://lter.github.io/ltertools/) to perform any needed harmonization. This package relies on a \"column key\" to translate the original column names into equivalents that apply across all datasets. Users can generate this column key however they would like but Google Sheets is a strong option as it allows multiple synthesis team members to simultaneously work on filling in the needed bits of the key.\n\nThe column key requires three columns:\n\n1. \"source\" -- Name of the raw file\n2. \"raw_name\" -- Name of all raw columns in that file to be synonymized\n3. \"tidy_name\" -- New name for each raw column that should be carried to the harmonized data\n\nNote that any raw names either not included in the column key or that lack a tidy name equivalent will be excluded from the final data object. For more information, consult the `ltertools` [package vignette](https://lter.github.io/ltertools/articles/ltertools.html). For convenience, we're attaching the visual diagram of this method of harmonization from the package vignette.\n\n<p align=\"center\">\n<img src=\"images/image_harmonize-workflow.png\" alt=\"Four color-coded tables are in a soft rectangle. One is pulled out and its column names are replaced based on their respective 'tidy names' in the column key table. This is done for each of the other tables then the four tables--with fixed column names--are combined into a single data table\" width=\"90%\">\n</p>\n\n## Wrangling Data\n\nData wrangling is a _huge_ subject that covers a wide range of topics. In this part of the module, we'll attempt to touch on a wide range of tools that may prove valuable to your data wrangling efforts. This is certainly non-exhaustive and you'll likely find new tools that fit your coding style and professional intuition better. However, hopefully the topics covered below provide a nice 'jumping off' point to reproducibly prepare your data for analysis and visualization work later in the lifecycle of the project.\n\nThis module will use example data to demonstrate these tools but as we work through these topics you should <u>feel free to substitute a dataset of your choosing</u>! If you don't have one in mind, you can use the example dataset shown in the code chunks throughout this module.\n\nThis dataset comes from the [`lterdatasampler` R package](https://lter.github.io/lterdatasampler/) and the data are about fiddler crabs (_Minuca pugnax_) at the [Plum Island Ecosystems LTER](https://pie-lter.ecosystems.mbl.edu/welcome-plum-island-ecosystems-lter) site.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the lterdatasampler package\nlibrary(lterdatasampler)\n\n# Load the fiddler crab dataset\ndata(pie_crab)\n```\n:::\n\n\n### Exploring the Data\n\nBefore beginning any code operations, it's important to get a sense for the data. Characteristics like the dimensions of the dataset, the column names, and the type of information stored in each column are all crucial pre-requisites to knowing what tools can or should be used on the data.\n\nChecking the data structure is one way of getting a lot of this high-level information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check dataset structure\nstr(pie_crab)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [392 × 9] (S3: tbl_df/tbl/data.frame)\n $ date         : Date[1:392], format: \"2016-07-24\" \"2016-07-24\" ...\n $ latitude     : num [1:392] 30 30 30 30 30 30 30 30 30 30 ...\n $ site         : chr [1:392] \"GTM\" \"GTM\" \"GTM\" \"GTM\" ...\n $ size         : num [1:392] 12.4 14.2 14.5 12.9 12.4 ...\n $ air_temp     : num [1:392] 21.8 21.8 21.8 21.8 21.8 ...\n $ air_temp_sd  : num [1:392] 6.39 6.39 6.39 6.39 6.39 ...\n $ water_temp   : num [1:392] 24.5 24.5 24.5 24.5 24.5 ...\n $ water_temp_sd: num [1:392] 6.12 6.12 6.12 6.12 6.12 ...\n $ name         : chr [1:392] \"Guana Tolomoto Matanzas NERR\" \"Guana Tolomoto Matanzas NERR\" \"Guana Tolomoto Matanzas NERR\" \"Guana Tolomoto Matanzas NERR\" ...\n```\n:::\n:::\n\n\nFor data that are primarily numeric, you may find data summary functions to be valuable. Note that most functions of this type do not provide useful information on text columns so you'll need to find that information elsewhere.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get a simple summary of the data\nsummary(pie_crab)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      date               latitude         site                size      \n Min.   :2016-07-24   Min.   :30.00   Length:392         Min.   : 6.64  \n 1st Qu.:2016-07-28   1st Qu.:34.00   Class :character   1st Qu.:12.02  \n Median :2016-08-01   Median :39.10   Mode  :character   Median :14.44  \n Mean   :2016-08-02   Mean   :37.69                      Mean   :14.66  \n 3rd Qu.:2016-08-09   3rd Qu.:41.60                      3rd Qu.:17.34  \n Max.   :2016-08-13   Max.   :42.70                      Max.   :23.43  \n    air_temp      air_temp_sd      water_temp    water_temp_sd  \n Min.   :10.29   Min.   :6.391   Min.   :13.98   Min.   :4.838  \n 1st Qu.:12.05   1st Qu.:8.110   1st Qu.:14.33   1st Qu.:6.567  \n Median :13.93   Median :8.410   Median :17.50   Median :6.998  \n Mean   :15.20   Mean   :8.654   Mean   :17.65   Mean   :7.252  \n 3rd Qu.:18.63   3rd Qu.:9.483   3rd Qu.:20.54   3rd Qu.:7.865  \n Max.   :21.79   Max.   :9.965   Max.   :24.50   Max.   :9.121  \n     name          \n Length:392        \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n```\n:::\n:::\n\n\nFor text columns it can sometimes be useful to simply look at the unique entries in a given column and sort them alphabetically for ease of parsing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Look at the sites included in the data\nsort(unique(pie_crab$site))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"BC\"  \"CC\"  \"CT\"  \"DB\"  \"GTM\" \"JC\"  \"NB\"  \"NIB\" \"PIE\" \"RC\"  \"SI\"  \"VCR\"\n[13] \"ZI\" \n```\n:::\n:::\n\n\nFor those of you who think more visually, a histogram can be a nice way of examining numeric data. There are simple histogram functions in the 'base' packages of most programming languages but it can sometimes be worth it to use those from special libraries because they can often convey additional detail.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load the psych library\nlibrary(psych)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'psych'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:ggplot2':\n\n    %+%, alpha\n```\n:::\n\n```{.r .cell-code}\n# Get the histogram of crab \"size\" (carapace width in mm)\npsych::multi.hist(pie_crab$size)\n```\n\n::: {.cell-output-display}\n![](mod_wrangle_files/figure-html/multi-hist-1.png){fig-align='center' width=384}\n:::\n:::\n\n\n### Quality Control\n\nYou may have encountered the phrase \"QA/QC\" (<u>Q</u>uality <u>A</u>ssurance / <u>Q</u>uality <u>C</u>ontrol) in relation to data cleaning. Technically, quality assurance only encapsulates _preventative_ measures for reducing errors. One example of QA would be using a template for field datasheets because using standard fields reduces the risk that data are recorded inconsistently and/or incompletely. Quality control on the other hand refers to all steps taken to resolve errors _after_ data are collected. Any code that you write to fix typos or remove outliers from a dataset falls under the umbrella of QC.\n\nIn synthesis work, QA is only very rarely an option. You'll be working with datasets that have already been collected and attempting to handle any issues _post hoc_ which means the vast majority of data wrangling operations will be quality control methods. These QC efforts can be **incredibly** time-consuming so using a programming language (like {{< fa brands r-project >}} R or {{< fa brands python >}} Python) is a dramatic improvement over manually looking through the data using Microsoft Excel or other programs like it.\n\n#### Number Checking\n\nWhen you read in a dataset and a column that _should be_ numeric is instead read in as a character, it can be a sign that there are malformed numbers lurking in the background. Checking for and resolving these non-numbers is preferable to simply coercing the column into being numeric because the latter method typically changes those values to 'NA' where a human might be able to deduce the true number each value 'should be.'\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the supportR package\nlibrary(supportR)\n\n# Create an example dataset with non-numbers in ideally numeric columns\nfish_ct <- data.frame(\"species\" = c(\"salmon\", \"bass\", \"halibut\", \"moray eel\"),\n                      \"count\" = c(12, \"14x\", \"_23\", 1))\n\n# Check for malformed numbers in column(s) that should be numeric\nbad_nums <- supportR::num_check(data = fish_ct, col = \"count\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFor 'count', 2 non-numbers identified: '14x' | '_23'\n```\n:::\n:::\n\n\nIn the above example, \"14x\" would be coerced to NA if you simply force the column without checking but you could drop the \"x\" with text replacing methods once you use tools like this one to flag it for your attention.\n\n#### Text Replacement\n\nOne of the simpler ways of handling text issues is just to replace a string with another string. Most programming languages support this functionality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use pattern match/replace to simplify problem entries\nfish_ct$count <- gsub(pattern = \"x|_\", replacement = \"\", x = fish_ct$count)\n\n# Check that they are fixed\nbad_nums <- supportR::num_check(data = fish_ct, col = \"count\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFor 'count', no non-numeric values identified.\n```\n:::\n:::\n\n\nThe vertical line in the `gsub` example above lets us search for (and replace) multiple patterns. Note however that while you can search for many patterns at once, only a single replacement value can be provided with this function.\n\n#### Regular Expressions\n\nYou may sometimes want to perform more generic string matching where you don't necessarily know--or want to list--all possible strings to find and replace. For instance, you may want remove any letter in a numeric column or find and replace numbers with some sort of text note. \"Regular expressions\" are how programmers specify these generic matches and using them can be a nice way of streamlining code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a test vector\nregex_vec <- c(\"hello\", \"123\", \"goodbye\", \"456\")\n\n# Find all numbers and replace with the letter X\ngsub(pattern = \"[[:digit:]]\", replacement = \"x\", x = regex_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hello\"   \"xxx\"     \"goodbye\" \"xxx\"    \n```\n:::\n\n```{.r .cell-code}\n# Replace any number of letters with only a single 0\ngsub(pattern = \"[[:alpha:]]+\", replacement = \"0\", x = regex_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0\"   \"123\" \"0\"   \"456\"\n```\n:::\n:::\n\n\n### Conditionals\n\nRather than finding and replacing content, you may want to create a new column based on the contents of a different column. In plain language you might phrase this as 'if column X has \\[some values\\] then column Y should have \\[other values\\]'. These operations are called <u>conditionals</u> and are an important part of data wrangling.\n\nIf you only want your conditional to support two outcomes (as in an either/or statement) there are useful functions that support this. Let's return to our Plum Island Ecosystems crab dataset for an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a new colum with an either/or conditional\npie_crab_v2 <- pie_crab %>% \n  dplyr::mutate(size_category = ifelse(test = (size >= 15), # <1>\n                                       yes = \"big\",\n                                       no = \"small\"),\n                .after = size) \n\n# Count the number of crabs in each category\npie_crab_v2 %>% \n  dplyr::group_by(size_category) %>% \n  dplyr::summarize(crab_ct = dplyr::n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  size_category crab_ct\n  <chr>           <int>\n1 big               179\n2 small             213\n```\n:::\n:::\n\n1. `mutate` makes a new column, `ifelse` is actually doing the conditional\n\nIf you have multiple different conditions you _can_ just stack these either/or conditionals together but this gets cumbersome quickly. It is preferable to instead use a function that supports as many alternates as you want!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a new column with several conditionals\npie_crab_v2 <- pie_crab %>% \n  dplyr::mutate(size_category = dplyr::case_when( \n    size <= 10 ~ \"tiny\", # <1>\n    size > 10 & size <= 15 ~ \"small\",\n    size > 15 & size <= 20 ~ \"big\",\n    size > 20 ~ \"huge\",\n    TRUE ~ \"uncategorized\"), # <2>\n                .after = size)\n\n# Count the number of crabs in each category\npie_crab_v2 %>% \n  dplyr::group_by(size_category) %>% \n  dplyr::summarize(crab_ct = dplyr::n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  size_category crab_ct\n  <chr>           <int>\n1 big               150\n2 huge               28\n3 small             178\n4 tiny               36\n```\n:::\n:::\n\n1. Syntax is 'test ~ what to do when true'\n2. This line is a catch-all for any rows that _don't_ meet previous conditions\n\nNote that you can use functions like this one when you do have an either/or conditional if you prefer this format.\n\n### Uniting / Separating Columns\n\nSometimes one column has multiple pieces of information that you'd like to consider separately. A date column is a common example of this because particular months are always in a given season regardless of the specific day or year. So, it can be useful to break a complete date (i.e., year/month/day) into its component bits to be better able to access those pieces of information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split date into each piece of temporal info\npie_crab_v3 <- pie_crab_v2 %>% \n  tidyr::separate_wider_delim(cols = date, \n                              delim = \"-\", # <1>\n                              names = c(\"year\", \"month\", \"day\"),\n                              cols_remove = TRUE) # <2>\n\n# Check that out\nstr(pie_crab_v3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [392 × 12] (S3: tbl_df/tbl/data.frame)\n $ year         : chr [1:392] \"2016\" \"2016\" \"2016\" \"2016\" ...\n $ month        : chr [1:392] \"07\" \"07\" \"07\" \"07\" ...\n $ day          : chr [1:392] \"24\" \"24\" \"24\" \"24\" ...\n $ latitude     : num [1:392] 30 30 30 30 30 30 30 30 30 30 ...\n $ site         : chr [1:392] \"GTM\" \"GTM\" \"GTM\" \"GTM\" ...\n $ size         : num [1:392] 12.4 14.2 14.5 12.9 12.4 ...\n $ size_category: chr [1:392] \"small\" \"small\" \"small\" \"small\" ...\n $ air_temp     : num [1:392] 21.8 21.8 21.8 21.8 21.8 ...\n $ air_temp_sd  : num [1:392] 6.39 6.39 6.39 6.39 6.39 ...\n $ water_temp   : num [1:392] 24.5 24.5 24.5 24.5 24.5 ...\n $ water_temp_sd: num [1:392] 6.12 6.12 6.12 6.12 6.12 ...\n $ name         : chr [1:392] \"Guana Tolomoto Matanzas NERR\" \"Guana Tolomoto Matanzas NERR\" \"Guana Tolomoto Matanzas NERR\" \"Guana Tolomoto Matanzas NERR\" ...\n```\n:::\n:::\n\n1. 'delim' is short for \"delimiter\" which we covered in the Reproducibility module\n2. This argument specifies whether to remove the original column when making the new columns\n\nWhile breaking apart a column's contents can be useful, it can also be helpful to combine the contents of several columns!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Re-combine data information back into date\npie_crab_v4 <- pie_crab_v3 %>% \n  tidyr::unite(col = \"date\",\n               sep = \"/\", # <1>\n               year:day, \n               remove = FALSE) # <2>\n\n# Structure check\nstr(pie_crab_v4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [392 × 13] (S3: tbl_df/tbl/data.frame)\n $ date         : chr [1:392] \"2016/07/24\" \"2016/07/24\" \"2016/07/24\" \"2016/07/24\" ...\n $ year         : chr [1:392] \"2016\" \"2016\" \"2016\" \"2016\" ...\n $ month        : chr [1:392] \"07\" \"07\" \"07\" \"07\" ...\n $ day          : chr [1:392] \"24\" \"24\" \"24\" \"24\" ...\n $ latitude     : num [1:392] 30 30 30 30 30 30 30 30 30 30 ...\n $ site         : chr [1:392] \"GTM\" \"GTM\" \"GTM\" \"GTM\" ...\n $ size         : num [1:392] 12.4 14.2 14.5 12.9 12.4 ...\n $ size_category: chr [1:392] \"small\" \"small\" \"small\" \"small\" ...\n $ air_temp     : num [1:392] 21.8 21.8 21.8 21.8 21.8 ...\n $ air_temp_sd  : num [1:392] 6.39 6.39 6.39 6.39 6.39 ...\n $ water_temp   : num [1:392] 24.5 24.5 24.5 24.5 24.5 ...\n $ water_temp_sd: num [1:392] 6.12 6.12 6.12 6.12 6.12 ...\n $ name         : chr [1:392] \"Guana Tolomoto Matanzas NERR\" \"Guana Tolomoto Matanzas NERR\" \"Guana Tolomoto Matanzas NERR\" \"Guana Tolomoto Matanzas NERR\" ...\n```\n:::\n:::\n\n1. This is equivalent to the 'delim' argument in the previous function\n2. Comparable to the 'cols_remove' argument in the previous function\n\nNote in this output how despite re-combining data information the column is listed as a character column! Simply combining or separating data is not always enough so you need to really lean into frequent data structure checks to be sure that your data are structured in the way that you want.\n\n### Joining Data\n\nOften the early steps of a synthesis project involve combine the data tables horizontally. You might imagine that you have two groups' data on sea star abundance and--once you've synonymized the column names--you can simply 'stack' the tables on top of one another. Slightly trickier but no less common is combining tables by the contents of a shared column (or columns). Cases like this include wanting to combine your sea star table with ocean temperature data from the region of each group's research. You can't simply attach the columns because that assumes that the row order is identical between the two data tables (and indeed, that there are the same number of rows in both to begin with!). In this case, if both data tables shared some columns (perhaps \"site\" and coordinate columns) you can use **joins** to let your computer match these key columns and make sure that only appropriate rows are combined.\n\nBecause joins are completely dependent upon the value in both columns being an _exact_ match, it is a good idea to carefully check the contents of those columns before attempting a join to make sure that the join will be successful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a fish taxonomy dataframe that corresponds with the earlier fish dataframe\nfish_tax <- data.frame(\"species\" = c(\"salmon\", \"bass\", \"halibut\", \"eel\"),\n                       \"family\" = c(\"Salmonidae\", \"Serranidae\", \"Pleuronectidae\", \"Muraenidae\"))\n\n# Check to make sure that the 'species' column matches between both tables\nsupportR::diff_check(old = fish_ct$species, new = fish_tax$species) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFollowing element(s) found in old object but not new: \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"moray eel\"\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFollowing element(s) found in new object but not old: \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"eel\"\n```\n:::\n\n```{.r .cell-code}\n# Use text replacement methods to fix that mistake in one table\nfish_tax_v2 <- fish_tax %>% \n  dplyr::mutate(species = gsub(pattern = \"^eel$\", replacement = \"moray eel\", x = species))\n\n# Re-check to make sure that fixed it\nsupportR::diff_check(old = fish_ct$species, new = fish_tax_v2$species)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nAll elements of old object found in new\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAll elements of new object found in old\n```\n:::\n:::\n\n\nNow that the shared column matches between the two two dataframes we can use a join to combine them! There are four types of join:\n\n1. Left/right join\n2. full join (a.k.a. outer join)\n3. inner join\n4. anti join\n\nYou can learn more about the types of join [here](https://nceas.github.io/scicomp-workshop-tidyverse/join.html) or [here](https://njlyon0.github.io/teach_r-for-biologists/materials/slides_4a.html#/title-slide) but the quick explanation is that <u>the name of the join indicates whether the rows of the \"left\" and/or the \"right\" table are retained in the combined table</u>. In synthesis work a left join or full join is most common (where you have your primary data in the left position and some ancillary/supplementary dataset in the right position).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's combine the fish count and fish taxonomy information\nfish_df <- fish_ct %>% \n  # Actual join step\n  dplyr::left_join(y = fish_tax_v2, by = \"species\") %>%  # <1>\n  # Move 'family' column to the left of all other columns\n  dplyr::relocate(family, .before = dplyr::everything())\n\n# Look at the result of that\nfish_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          family   species count\n1     Salmonidae    salmon    12\n2     Serranidae      bass    14\n3 Pleuronectidae   halibut    23\n4     Muraenidae moray eel     1\n```\n:::\n:::\n\n1. The 'by' argument accepts a vector of column names found in both data tables\n\n### Leveraging Data Shape\n\nYou may already be familiar with data shape but fewer people recognize how playing with the shape of data can make certain operations _dramatically_ more efficient. If you haven't encountered it before, any data table can be said to have one of two 'shapes': either **long** or **wide**. Wide data have all measured variables from a single observation in one row (typically resulting in more columns than rows or \"wider\" data tables). Long data usually have one observation split into many rows (typically resulting in more rows than columns or \"longer\" data tables).\n\nData shape is often important for statistical analysis or visualization but it has an under-appreciated role to play in quality control efforts as well. If many columns have the shared criteria for what constitutes \"tidy\", you can reshape the data to get all of those values into a single column (i.e., reshape longer), perform any needed wrangling, then--when you're finished--reshape back into the original data shape (i.e., reshape wider). As opposed to applying the same operations repeatedly to each column individually.\n\nLet's consider an example to help clarify this. We'll simulate a butterfly dataset where both the number of different species and their sex were recorded in the same column. This makes the column not technically numeric and therefore unusable in analysis or visualization.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate a butterfly dataframe\nbfly_v1 <- data.frame(\"pasture\" = c(\"PNW\", \"PNW\", \"RCS\", \"RCS\"),\n                      \"monarch\" = c(\"14m\", \"10f\", \"7m\", \"16f\"),\n                      \"melissa_blue\" = c(\"32m\", \"2f\", \"6m\", \"0f\"),\n                      \"swallowtail\" = c(\"1m\", \"3f\", \"0m\", \"5f\"))\n\n# First we'll reshape this into long format\nbfly_v2 <- bfly_v1 %>% \n  tidyr::pivot_longer(cols = -pasture, \n                      names_to = \"butterfly_sp\", \n                      values_to = \"count_sex\")\n\n# Check what that leaves us with\nhead(bfly_v2, n = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  pasture butterfly_sp count_sex\n  <chr>   <chr>        <chr>    \n1 PNW     monarch      14m      \n2 PNW     melissa_blue 32m      \n3 PNW     swallowtail  1m       \n4 PNW     monarch      10f      \n```\n:::\n\n```{.r .cell-code}\n# Let's separate count from sex to be more usable later\nbfly_v3 <- bfly_v2 %>% \n  tidyr::separate_wider_regex(cols = count_sex, \n                              c(count = \"[[:digit:]]+\", sex = \"[[:alpha:]]\")) %>% \n  # Make the 'count' column a real number now\n  dplyr::mutate(count = as.numeric(count))\n\n# Re-check output\nhead(bfly_v3, n = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  pasture butterfly_sp count sex  \n  <chr>   <chr>        <dbl> <chr>\n1 PNW     monarch         14 m    \n2 PNW     melissa_blue    32 m    \n3 PNW     swallowtail      1 m    \n4 PNW     monarch         10 f    \n```\n:::\n\n```{.r .cell-code}\n# Reshape back into wide-ish format\nbfly_v4 <- bfly_v3 %>% \n  tidyr::pivot_wider(names_from = \"butterfly_sp\", values_from = count)\n\n# Re-re-check output\nhead(bfly_v4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  pasture sex   monarch melissa_blue swallowtail\n  <chr>   <chr>   <dbl>        <dbl>       <dbl>\n1 PNW     m          14           32           1\n2 PNW     f          10            2           3\n3 RCS     m           7            6           0\n4 RCS     f          16            0           5\n```\n:::\n:::\n\n\nWhile we absolutely _could_ have used the same function to break apart count and butterfly sex data it would have involved copy/pasting the same information repeatedly. By pivoting to long format first, we can greatly streamline our code. This can also be advantageous for unit conversions, applying data transformations, or checking text column contents among many other possible applications.\n\n### Loops\n\nAnother way of simplfying repetitive operations is to use a \"for loop\" (often called simply \"loops\"). Loops allow you to iterate across a piece of code for a set number of times. Loops require you to define an \"index\" object that will change itself at the end of each iteration of the loop before beginning the next iteration. This index object's identity will be determined by whatever set of values you define at the top of the loop.\n\nHere's a very bare bones example to demonstrate the fundamentals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loop across each number between 2 and 4\nfor(k in 2:4){ # <1>\n  \n  # Square the number\n  result <- k^2\n  \n  # Message that outside of the loop\n  message(k, \" squared is \", result)\n} # <2>\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2 squared is 4\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n3 squared is 9\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n4 squared is 16\n```\n:::\n:::\n\n1. 'k' is our index object in this loop\n2. Note that the operations to iterate across are wrapped in curly braces (`{...}`)\n\nOnce you get the hang of loops, they can be a nice way of simplifying your code in a relatively human-readable way! Let's return to our Plum Island Ecosystems crab dataset for a more nuanced example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create an empty list\ncrab_list <- list()\n\n# Let's loop across size categories of crab\nfor(focal_size in unique(pie_crab_v4$size_category)){ # <1>\n  \n  # Subset the data to just this size category\n  focal_df <- pie_crab_v4 %>% \n    dplyr::filter(size_category == focal_size)\n  \n  # Calculate average and standard deviation of size within this category\n  size_avg <- mean(focal_df$size, na.rm = T) \n  size_dev <- sd(focal_df$size, na.rm = T) \n  \n  # Assemble this into a data table and add to our list\n  crab_list[[focal_size]] <- data.frame(\"size_category\" = focal_size,\n                                        \"size_mean\" = size_avg,\n                                        \"size_sd\" = size_dev)\n} # Close loop\n\n# Unlist the outputs into a dataframe\ncrab_df <- purrr::list_rbind(x = crab_list)\n\n# Check out the resulting data table\ncrab_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  size_category size_mean   size_sd\n1         small 12.624270 1.3827471\n2          tiny  8.876944 0.9112686\n3           big 17.238267 1.3650173\n4          huge 21.196786 0.8276744\n```\n:::\n:::\n\n1. Note that this is not the most efficient way of doing group-wise summarization but is--hopefully--a nice demonstration of loops!\n\n### Custom Functions\n\n\n\n\n\n\n\n\n\n\n\n\n## Additional Resources\n\n### Papers & Documents\n\n- \n\n### Workshops & Courses\n\n- Data Analysis and Visualization in R for Ecologists, [Episode 4: Manipulating, Analyzing, and Exporting Data with `tidyverse`](https://datacarpentry.org/R-ecology-lesson/03-dplyr.html). The Carpentries\n- [Coding in the Tidyverse](https://nceas.github.io/scicomp-workshop-tidyverse/). NCEAS Scientific Computing Team, 2023.\n- coreR Course, [Chapter 8: Cleaning & Wrangling Data](https://learning.nceas.ucsb.edu/2023-10-coreR/session_08.html). NCEAS Learning Hub, 2023.\n- coreR Course, [Chapter 16: Writing Functions & Packages](https://learning.nceas.ucsb.edu/2023-10-coreR/session_16.html). NCEAS Learning Hub, 2023.\n\n### Websites\n\n- \n",
    "supporting": [
      "mod_wrangle_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}