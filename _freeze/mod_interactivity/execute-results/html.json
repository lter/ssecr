{
  "hash": "8dc97429cb5f60c9354545bb10dedf68",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Creating Interactive Apps\"\ncode-annotations: hover\nexecute: \n    eval: false\n---\n\n\n## Overview\n\nShiny is a popular tool that allows users to build interactive web applications without the normally pre-requisite web development expertise. In addition to Shiny apps being simpler to build for the programmer they are often used to allow visitors to perform coding tasks without ever actually writing code. These are huge advantages because they reduce or eliminate significant technical barriers in developing truly interactive applications.\n\nIn synthesis contexts, Shiny can be used for a variety of valuable purposes. You can use it to develop dashboards for sharing data with related communities, allow your team to quickly \"play with\" exploratory graphs, or even to create a data submission portal (as is the case with some <u>R</u>esearch <u>C</u>oordination <u>N</u>etworks or \"RCNs\").\n\nNote that Shiny can be built in either R or Python 'under the hood' but for the purposes of this module we'll focus on R.\n\n## Learning Objectives\n\nAfter completing this topic you will be able to: \n\n- <u>Define</u> the three fundamental components of a Shiny app\n- <u>Explain</u> benefits and limitations of interactive approaches to data exploration\n- <u>Generate</u> an interactive app with Shiny\n- <u>Use</u> text formatting methods in a Shiny app\n- <u>Explore</u> available Shiny layout options\n- <u>Create</u> a Shiny app\n- <u>Describe</u> (briefly) the purpose of deploying a Shiny app\n\n## Needed Packages\n\nIf you'd like to follow along with the code chunks included throughout this module, you'll need to install the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note that these lines only need to be run once per computer\n## So you can skip this step if you've installed these before\ninstall.packages(\"tidyverse\")\ninstall.packages(\"shiny\")\ninstall.packages(\"htmltools\")\ninstall.packages(\"lterdatasampler\")\n```\n:::\n\n\nWe'll load the Tidyverse meta-package here to have access to many of its useful tools when we need them later as well as the `shiny` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load needed libraries\nlibrary(tidyverse); library(shiny)\n```\n:::\n\n\n## Shiny Fundamentals\n\nAll Shiny apps are composed of three pieces: a <u>u</u>ser <u>i</u>nterface (UI), a server, and a call to the `shinyApp` function. The user interface includes everything that the user sees and can interact with; note that this includes _both_ inputs and outputs. The server is responsible for all code operations performed on user inputs in order to generate outputs specified in the UI. The server is _not_ available to the user. Finally, the `shinyApp` function simply binds together the UI and server and creates a living app. The app appears either in your RStudio or in a new tab on a web browser depending on your settings.\n\nFor those of you who write your own functions, you may notice that the syntax of Shiny is **very** similar to the syntax of functions. If you have not already, your quality of life will benefit greatly if you turn on \"rainbow parentheses\" in RStudio (Tools {{< fa arrow-right >}} Global Options {{< fa arrow-right >}} Code {{< fa arrow-right >}} Display {{< fa arrow-right >}} Check \"Use rainbow parentheses\" box).\n\nLet's consider an artificially simple Shiny app so you can get a sense for the fundamental architecture of this tool.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the UI\nbasic_ui <- shiny::fluidPage( # <1>\n  \"Hello there!\"\n)\n\n# Define the server\nbasic_server <- function(input, output){ } # <2>\n\n# Generate the app\nshiny::shinyApp(ui = basic_ui, server = basic_server)\n```\n:::\n\n1. The `fluidPage` function is important for leaving flexibility in UI layout which we'll explore later in the module\n2. Because this app has no inputs or outputs, it doesn't need anything in the 'server' component (though it still does require an empty server!)\n\nIf you copy and run the above code, you should see an app that is a blank white page with \"Hello there!\" written in the top left in plain text. Congratulations, you have now made your first Shiny app! Now, your reason for exploring this module likely involves an app that actually does something but the fundamental structure of all apps--even skeletal apps like this one--is the same. More complicated apps will certainly have more content in the UI and server sections but all Shiny apps will have this tripartite structure.\n\n## Interactive Apps\n\nNow that we've covered non-reactive apps, let's create an interactive one! It is important to remember that the user interface needs to contain _both_ the inputs the user can make _and_ the outputs determined by those inputs. The server will be responsible for turning the inputs into outputs but if you want your interactive app to actually show the user the interactivity you need to be careful to include the outputs in the UI.\n\nEssentially all Shiny UI functions use the same syntax of `<value class>Input` or `<value class>Output`. So, determining how you want the user to engage with your app is sometimes as straightforward as identifying the class of the value you want them to interact with. <u>Shiny calls these helper functions \"widgets\".</u>\n\nLet's consider an app that accepts a single number and returns the square root of that number.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the UI ---- \nreactive_ui <- shiny::fluidPage(\n  \n  # Create input\n  shiny::numericInput(inputId = \"num_in\", # <1>\n                      label = \"Type a number\",\n                      value = 16),\n  \n  # Include some plain text for contextualizing the output\n  \"Square root is: \", # <2>\n  \n  # Create output\n  shiny::textOutput(outputId = \"num_out\")\n  \n) # Close UI\n\n# Define server ----\nreactive_server <- function(input, output){\n  \n  # Reactively accept the input and take the square root of it\n  root <- shiny::reactive({ # <3>\n    sqrt(x = input$num_in) # <4>\n  })\n  \n  # Make that value an output of the server/app\n  output$num_out <- shiny::renderText( # <5>\n    expr = root() # <6>\n  ) \n  \n} # Close server\n\n# Generate the app ----\nshiny::shinyApp(ui = reactive_ui, server = reactive_server)\n```\n:::\n\n1. Note that the argument name is capital \"I\" but _lowercase_ \"d\". Typing `inputID` is a common and frustrating source of error for Shiny app developers\n2. Every element of the UI--except the last one--needs to end with a comma\n3. All reactive elements (i.e., those that change as soon as the user changes an input) need to be specified inside of `reactive` with _both_ parentheses and curly braces\n4. The name of this input exactly matches the `inputId` we defined in the UI. That it _is_ an input is defined by our use of the `numericInput` widget\n5. The name of this output exactly matches the `outputId` we told the UI to expect.\n6. Reactive elements essentially become functions in their own right! So, when we want to use them, we need to include empty parentheses next to their name\n\nWe included a _lot_ of footnote annotations in that code chunk to help provide context but there are a few small comments that are worthwhile to bring up at this stage.\n\n1. UI outputs and server renders _must_ match\n\nThe widget you use in the UI to return an output must correspond to the function used in the server to generate that output. In this example, we use `textOutput` in the UI so in the server we use `renderText`. Essentially all widgets in Shiny use this `<class>Output` versus `render<Class>` syntax which can be a big help to visual checks that your app is written correctly. You will need to be sure that whatever the 'class' is, it is _lowercase_ in the UI but _title case_ in the server (i.e., only first letter capitalized).\n\n2. Use section header format\n\nThis app is relatively short but we think effectively hints at how long and convoluted purpose-built Shiny apps can easily become. So, we recommend using section headers in your Shiny app code. You can do this by putting either four hyphens or four hashtags at the end of a comment line (e.g., `# Section 1 ####` or `# My header ----`). Headings defined in this way will appear in the bottom left of the \"Source\" pane of RStudio next to a light orange hashtag symbol. Clicking the text in that area will open a drop-down menu showing all headings in your current file and clicking one of the other headings will instantly jump you to that heading. This can be _incredibly_ convenient when you're trying to navigate a several hundred line long Shiny app. While rainbow parentheses can be useful for avoiding typos _within a section_, section headers make it much easier to avoid typos _across_ sections.\n\nIf you don't use headings already (or your cursor is on a line before the first heading), the relevant bit of the \"Source\" pane will just say \"(Top Level)\" and will not have the golden hashtag symbol.\n\n## Including Data\n\nYou can also use your Shiny app to work with a full data table! When running your app locally, you only need to read in the data as you normally would then run the app. By having read in the data you will ensure the object is in your environment and accessible to the app. However, keep in mind this will only work in \"local\" (i.e., non-deployed) contexts. See our--admittedly brief--discussion of deployment at the end of this module.\n\nLet's explore an example using data about fiddler crabs (_Minuca pugnax_) at the [Plum Island Ecosystems (PIE) LTER](https://pie-lter.ecosystems.mbl.edu/welcome-plum-island-ecosystems-lter) site from the [`lterdatasampler` R package](https://lter.github.io/lterdatasampler/). The app we're about to create will make a graph between any two (numeric) columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load fiddler crab data\ndata(pie_crab) # <1>\n\n# Define the UI ---- \ndata_ui <- shiny::fluidPage(\n  \n  # Let the user choose which the X axis\n  shiny::selectInput(inputId = \"x_vals\",\n              label = \"Choose the X-axis\",\n              choices = setdiff(x = names(pie_crab), # <2>\n                                y = c(\"date\", \"site\", \"name\")),\n              selected = \"latitude\"),\n  \n  # Also the Y axis\n  shiny::selectInput(inputId = \"y_vals\",\n              label = \"Choose the Y-axis\",\n              choices = setdiff(x = names(pie_crab),\n                                y = c(\"date\", \"site\", \"name\")),\n              selected = \"size\"),\n  \n  # Return the desired plot\n  shiny::plotOutput(outputId = \"crab_graph\")\n              \n) # Close UI\n\n# Define the server ----\ndata_server <- function(input, output){\n  \n  # Reactively identify X & Y axess\n  picked_x <- shiny::reactive({ input$x_vals }) # <3>\n  picked_y <- shiny::reactive({ input$y_vals })\n  \n  # Create the desired graph\n  output$crab_graph <- shiny::renderPlot(\n    \n    ggplot(pie_crab, aes(x = .data[[picked_x()]], y = .data[[picked_y()]])) + # <4>\n      geom_point(aes(fill = .data[[picked_x()]]), pch = 21, size = 2.5) +\n      labs(x = stringr::str_to_title(picked_x()),\n           y = stringr::str_to_title(picked_y())) +\n      theme_bw()\n    \n  ) # Close plot rendering\n  \n} # Close server\n\n# Generate the app ----\nshiny::shinyApp(ui = data_ui, server = data_server)\n```\n:::\n\n1. Note the loading of the data is done _outside_ of the app! You can have the app load its own data but that is more complicated than this example needs to be.\n2. To make our life easier in the server we can exclude non-number columns\n3. See how we're reactively grabbing both axes?\n4. `ggplot2` requires special syntax to specify axes with quoted column names (which is how reactive Shiny elements from that widget are returned)\n\n## Text Formatting\n\n\n\n## Layouts\n\n\n\n## Deployment\n\nWhen Shiny apps are only being used by those in your team, keeping them as a code script works well. However, if you'd like those outside of your team to be able to find your app as they would any other website you'll need to <u>deploy</u> your Shiny app. This process is outside of the scope of this module but is often the end goal of Shiny app development.\n\nTake a look at [Posit's instructions for deployment](https://shiny.posit.co/r/articles/share/deployment-web/) for more details but essentially \"deployment\" is the process of getting your local app hosted on shinyapps.io which gives it a link that anyone can use to access/run your app on their web browser of choice.\n\n## Additional Interactivity Resources\n\n### Papers & Documents\n\n- \n\n### Workshops & Courses\n\n- Posit's [Welcome to Shiny](https://shiny.posit.co/r/getstarted/shiny-basics/lesson1/index.html) (for R coders)\n- 2022 All Scientists' Meeting [Shiny Apps for Sharing Science](https://njlyon0.github.io/asm-2022_shiny-workshop/) workshop\n\n### Websites\n\n- Posit's [Shiny](https://shiny.posit.co/) website\n",
    "supporting": [
      "mod_interactivity_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}